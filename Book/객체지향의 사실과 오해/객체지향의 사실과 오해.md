[# 객체지향의 사실과 오해 - 조영호

## 목차

- [객체지향의 사실과 오해 - 조영호](#객체지향의-사실과-오해---조영호)
  - [목차](#목차)
  - [1장 협력하는 객체들의 공동체](#1장-협력하는-객체들의-공동체)
    - [객체 지향의 목적](#객체-지향의-목적)
    - [객체 지향의 본질](#객체-지향의-본질)
    - [역할, 책임, 협력](#역할-책임-협력)
  - [2장 이상한 나라의 객체](#2장-이상한-나라의-객체)
    - [상태](#상태)
    - [행동](#행동)
    - [식별자](#식별자)
    - [은유](#은유)
  - [3장 타입과 추상화](#3장-타입과-추상화)
    - [추상화](#추상화)
    - [타입](#타입)
  - [4장 역할, 책임, 협력](#4장-역할-책임-협력)
    - [협력](#협력)
    - [책임](#책임)
    - [역할](#역할)
  - [5장 책임과 메시지](#5장-책임과-메시지)
    - [책임과 메시지](#책임과-메시지)
  - [인터페이스](#인터페이스)
  - [6장 객체 지도](#6장-객체-지도)
    - [객체 지도](#객체-지도)
    - [기능 설계 대 구조 설계](#기능-설계-대-구조-설계)
  - [7장 함께 모으기](#7장-함께-모으기)
    - [상호 연관 관점](#상호-연관-관점)
  - [부록 A. 추상화 기법](#부록-a-추상화-기법)
    - [분류와 인스턴스화](#분류와-인스턴스화)
    - [일반화와 특수화](#일반화와-특수화)
    - [집합과 분해](#집합과-분해)

## 1장 협력하는 객체들의 공동체



## 2장 이상한 나라의 객체


### 행동

- 행동이란?
  - 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동
  - 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달 가능
    → 부수 효과(side effect)
  - 객체는 행동을 통해 다른 객체와의 협력에 참여함으로 행동은 외부에 가시적이어야 함
    → method는 특별한 이유가 없는 한 pubilc으로 해야한다?
- 객체의 행동은 아래의 두 가지 관점의 부수효과를 명확하게 서술해야한다.
  - 객체 자신의 상태 변경
  - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
- 상태와 행동 사이의 관계
  - 객체의 행동은 상태에 영향을 받는다.
    → 상호작용이 형재의 상태에 어떤 방식으로 의존하는가
  - 객체의 행동은 상태를 변경 시킨다.
    → 상호작용이 어떻게 현재의 상태를 변경시키는가

### 식별자

- 프로퍼티 ( = 식별자 )
  - 객체란 인간의 인지 능력을 이용해 식별 가능한 경계를 가진 모든 사물을 말한다.
  - 객체가 식별 가능하다는 것은 서로를 구별할 수 있는 특별한 프로퍼티를 가진다는 뜻이며 이러한 프러퍼티를 식별자라 부른다.
- 값(value)
  - 숫자, 문자열, 날짜, 시간 등과 같이 변하지 않은 “양”을 모델링한다.
  - 값의 상태는 변하지 않기 때문에 불변 상태(immutable state)를 가진다고 말한다.
    → 즉, 식별자를 가지지 않는다.
- 동등성(equality)과 동일성(identical)
  - 동등성 : 상태를 이용해 두 값이 같은지 판단할 수 있는 성질
  - 동일성 : 식별자를 기반으로 객체가 같은지 판단할 수 있는 성질
- 객체의 특성
  - 객체는 상태를 가지며 상태는 변경 가능하다.
  - 객체의 상태를 변경시키는 것은 객체의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
    - 행동의 순서가 실행 결과에 영향을 미친다.
  - 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

### 은유

- 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유이다. 이는 소프트웨어 객체가 실제 객체를 단순화하거나 추상화하는 것이 아니라 특성이 전혀 다른 것임을 의미한다.
- 의인화
  - 현실 송에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것.

## 3장 타입과 추상화

### 추상화

- 추상화란?
  > 어떤 양상, 세부 사항, 구조를 좀 거 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

  - 추상화가 이루어지는 두 차원
    1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것.
    2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것.

- 개념의 세 가지 관점
  > 공통점을 기반으로 객체들을 묶기 위한 그릇을 개념(concept)라고 한다.

  - 객체란 특정한 개념을 적용할 수 있는 사물이며, 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

<center>

|관점|뜻|
|:---:|:---|
|심볼(symbol)|개념을 가르키는 간략한 이름이나 명칭|
|내연(Intension)|개념의 완전한 정의를 나타내며 내연의 의미를 이용해서 객체가 개념이 속하는지 여부를 확인할 수 있다.|
|외연(Extension)|개념에 속하는 모든 객체의 집합(set)|

</center>

- 분류
  - 분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

### 타입

> “타입은 개념과 동일하다.” 
> 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

- 데이터 타입

    > 타입이 없는 체계 안에서 모든 데이터는 일련의 비트열(bit string)로 구성된다.

  - 타입에 대한 두가지 사실
    - 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
    - 타입에 속한 데이터를 메모리에 어떻게 표현하는지 외부로부터 철저하게 감춰진다.
  - 책 속의 정의
    - 데이터 타입은 메모리 안에 저장된 두 종류를 분류하는데 사용하는 메모리 집합에 대한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.



- 객체와 타입
  > 객체가 어떤 행동을 하느냐에 따라 객체의 타입이 결정된다.

  - 객체의 타입에 관한 두 가지 조언
    - 어떤 객체가 어떤 타입에 속하는지 결정하는 것은 객체가 수행하는 행동이다.
    - 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.
  - 행동이 우선이다.
    > 객체의 타입을 결정하는 것은 객체의 행동뿐이다. 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는 데 아무런 영향도 끼치지 않는다.

    - 다형성
      - 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 즉, 동일한 요청에 대해서 서로 다른 응답 방식을 취할 수 있다. → 오버라이딩

    - 캡슐화
      - 데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다. 즉, 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다.



- 타입의 계층
  > 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 “행동”이다.
  - 일반화/특수화 관계  
    - 일반적이라는 말은 더 포괄적이라는 의미를 내포하고 있다. 반대로 특수하다는 것은 좀 더 작은 범위를 다루는 것이다.  
  - 슈퍼타입 - 서브타입
    - 일반화/특수화 관계를 코드로 설명하게 되면 슈퍼타입이 일반적인 객체에 대한 내용을 다루게 될 것이고 서브 타입은 조금 더 특수한 내용을 다루게 될 것 이다.



- 타입의 목적
  - 정적 모델
    - 객체가 속한 타입의 정적인 모습을 표현.

  - 동적 모델
    - 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 표현

  - 타입 모델
    - 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현한 것

  - 클래스
    - 타입을 구현하는 가장 보편적인 방법
    - 타입과 클래스는 동일한 것이 아니며 클래스는 타입을 구현하기 위한 여러 매커니즘 중 하나이다.

## 4장 역할, 책임, 협력

### 협력
  
> 협력의 본질은 요청과 응답으로 연결되는 객체간의 네트워크이다.

- 협력은 한 객체가 다른 객체에게 도움을 요청할 떄 시작된다. 자신에게 할당된 일이나 업무를 처리하던 중에 스스로 해결하기 어려운 문제에 부딪히게 되면 문제를 해결하는 데 필요한 지식을 알고 있거나 도움을 받을 수 있는 누군가에게 도움을 요청하게 된다.

- [재판 속의 협력]
  - 누군가 왕에게 재판을 `요청`함으로써 재판이 시작된다.
  - 왕이 하얀 토끼에게 증인을 부를 것을 `요청`한다.
  - 왕의 요청을 받는 토끼는 모자 장수에게 증인석으로 입장할 것을 `요청`한다.
  - 모자 장수는 입장은 왕이 토기에게 요청했던 증인 호출에 대한 `응답`이기도 하다.
  - 모자 장수는 자신이 알고 있는 내용들을 증엄함으로써 왕의 요청에 `웅답`한다.
  - 어떤 등장인물들이 특정한 요청을 받아 들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 `지식과 행동 방식`을 가지고 있기 때문이다.

### 책임

> 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다. 또한 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에게 할당하는 것이라고 한다.

- [책임의 분류]
  - 하는 것(doing)
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것 ⇒ 응답
    - 다른 객체의 행동을 시작시키는 것 ⇒ 요청
    - 다른 객체의 활동을 제어하고 조절하는 것
  - 아는 것(knowing)
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

- [책임과 메시지]
  - 협럭 안에서 객체는 다른 객체로부터 요청이 전송됐을 경우에만 자신에게 주어진 책임을 수행한다.
  - 결국 한 객체가 다른 객체에게 전송된 요청은 그 요청을 수신할 객체의 책임이 수행되게한다. 이처럼 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내느것을 `메시지 전송`이라고 한다.메시지는 협력을 위한 객체가 다른 객체로 접근할 수 있는 유일한 방법이다.

### 역할

> 책임의 집합

- [역할이 답이다]
  - 재판이라는 협력 과정 속에서 하트 왕고 하트 여왕은 `판사`의 역할을 수행한다. 모자 장수와 요리사, 그리고 엘리스는 `증인`의 역할을 수행한다. 따라서 `판사`와 `증인`이라는 역할을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상회된다.
  - `역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다.` 협력안에서 역할은 "**이 자리는 해당 역할을 수핼할 수 있는 어떤 객체라도** 대신할 수 있습니다." 라고 말하는 것과 같다.

- [협력과 추상화]
  - 역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 `추상화`할 수 있다는 것이다. 따라서 역할을 이용하면 협력을 추상화함으로써 단순화 할 수 있다.

- [대체 가능성]
  > 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.
  - 객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다는 점에 주목하라.
  - 객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목하라.
  - 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. 즉, 대부분의 경우에 객체의 타임과 역할 사이에는 `일반화/특수화 관계`가 성립한다.

## 5장 책임과 메시지

### 책임과 메시지

> 훌륭한 객체지향의 세계는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호협력하는 세계이다.

- 자율적인 책임
  - 객체가 책임을 자율적으로 수행하기 위해서는 객체에 할당되는 책임 또한 자율적이어야 한다.
  - 너무 추상적인 책임은 해당 책임이 협력에 참여한 의도가 명확해지지 않기 때문에 협력의도를 뚜렷하게 표현할 수 있을 정도록 구체적이어야한다.

  - ["어떻게"가 아니라 "무엇"을]
    - 자율적인 책임의 특징은 객체가 `어떻게` 하는가가 아니라 `무엇`을 해야하는가를 설명한다.



- 메시지와 메서드

  - [메시지]
    - 하나의 객체는 `메시지`를 전송함으로써 다른 객체에 접근한다.
    - 왕이 모자 장수에게 전송하는 메시지인 ‘증언하라’라는 부분을 `message name`
    - 메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 `argument`를 이용한다.
    > `모자장수.증언하라(어제, 왕국);`

  - [메서드]
    - 객체가 수신할 수 있는 `메시지`와 메시지를 처리하기 위한 `방법`이라는 두 가지 개념이 존재한다.
    - 메시지를 처리하기 위해 내부적으로 선택하는 방법을 `메서드`라고 하며, 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.

  - [다형성]
    > 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. **좀 더 구체적으로 말하면 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니짐을 말한다.**

    - 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 `동일한 책임`을 공유한다는 것을 의미한다.
      - 다형성은 `수신자의 종류를 캡슐화`한다.
      - 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력의 유연성을 높일 수 있기 때문이다.

    - [유연하고 확장 가능하고 재사용성이 높은 협력의 의미]
      > 송신자가 수신자에 대해 매주 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.
        1. 협력이 유연해진다.
        2. 협력이 수행되는 방식을 확장할 수 있다.
        3. 협력이 수행되는 방식을 재사용할 수 있다.

## 인터페이스

> 일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용 할 수 있게 이어주는 방법이나 장치를 의미한다,

- 객체 인터페이스
  - [인터페이스의 3가지 특징]
    1. 인터페이스의 사용법만 알고 있으면 대상의 내부 구조나 동작 방법을 몰라도 상호작용이 가능하다.
    2. 인터페이스가 변경되지 않고 단순히 내부 구성이나 작동 방식이 변경되는 것은 인터페이스 사용자에게 아무런 영향도 미치지 않는다.
    3. 인터페이스가 동일하기만 하다면 어떤 대상과도 상호작용 할 수 있다.



- 인터페이스와 구현의 분리 원칙
  > 훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 이것은 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확하게 분리해서 고려하는 것을 의미한다.

  - [객체 관점에서 생각하는 방법]

    1. 좀 더 추상적인 인터페이스
       - 조금 더 추상적인 수준의 메세지를 수신할 수 있는 인터페이스를 제공하면 수신자의 자율성을 보장할 수 있다. 여시서 세부 사항을 제거하고 메시지의 의도를 표현하기 위해 사용한 기법이 추상화이며, 따라서 너무 주체적인 인터페이스보다는 추상적인 인터페이스를 설계하는 것이 좋다.

    2. 최소 인터페이스
        - 외부에서 사용할 필욕사 없은 인터페이스는 최대한 노출하지 말하는 것이다. 인터페이스를 최소로 유지하면 객체의 내부 동작에 대해 가능한 적은 정보만 외부에 노출할 수 있다. 이는 객체의 내부를 수정하더라도 외부에 미치는 영향을 최소화 할 수 있음을 의미한다.

    3. 인터페이스와 구현 간에 차이가 있다는 점을 인식
        - 객체의 외무와 내부를 분리하라는 것은 결국 객체의 공용 인터페이스와 구현을 명확하게 분리하라는 말과 같다.

  - [구현]

    - 객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현이다. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.
    - 객체는 상태를 가진다. 상태는 어떤 식으로든 객체에 포함되지만 공용 인터페이스의 일부는 아니다. 즉, 상태를 어떻게 표현할 것인가는 객체의 구현에 해당한다.
    - 객체는 행동을 가진다. 메서드(행동)을 구성하는 코드 자체는 객체 외부에 노출되는 공용 인터페이스의 일부는 아니기 때문에 객체의 구현 부분에 포함된다.



- 캡슐화
  > 인터페이스와 구현을 분리한다는 것은 변경될 만한 부분을 객체의 내부에 꽁꽁 숨겨놓는 다는 것을 의미하며, 이 원칙을 수행하기 위한 객체 설계 방법을 캡슐화 라고 한다.

  - [상태와 행위의 캡슐화]
    - 객체는 상태와 행위의 조합이다. 즉, 객체는 상태와 행동을 하나의 단위로 묶는 자율적인 실체다. 이 관점에서의 캡슐화를 데이터 캡슐화라고 한다.
    - 객체가 자율적이기 위해서는 자기 자신의 상태를 스스로 관리할 수 있어야 하기 때문에 데이터 캡슐화는 자율적인 객체를 만들기 위한 전제 조건이기도 하다.

  - [사적인 비밀의 캡슐화]
    - 객체는 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 막기 위해 의사소통 가능한 특별한 경로만 외부에 노출한다. ⇒ 공용 인터페이스
    - 외부에 제공할 필요가 있는 메시지만을 객체의 공용 인터페이스에 포함기키고 개인적인 비밀은 공용 인터페이스의 뒤에 감춤으로써 외부의 불필요한 공격과 간섭으로 부터 내부 상태를 격리할 수 있다. 즉, 객체는 공용 인터페이스를 경계로 최대한의 자율성을 보장 받을 수 있다.



- 객체의 자율성과 협력의 품질
  > 어떤 협력이 다른 협력보다 이해하기 쉽고 변경에 유연하면 그것을 조금 더 나은 설계의 형태라고 말한다. ⇒ 결과적으로 책임의 자율성이 협력의 품질을 결정함

    1. 자율적인 책임은 협력을 단순하게 만든다.
    2. 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.
    3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.
    4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
    5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.

## 6장 객체 지도

### 객체 지도

- 기능적이고 해결 지향적인 접근법:
  - `기능`에 초점을 맞추어 해결 방안을 제시하는 접근법으로 어떠한 문제를 해결하기 위한 기능은 일반적이지도, 재사용 가능하지도 못하다.

- 구조적이고 문제 지향적인 접근법:
  - `구조`를 기반으로 설계를 하게 되며 구조란 자주 바뀌지 않는 안정적인 형태를 말하기 때문에 높은 재사용 성을 가져다 준다.

### 기능 설계 대 구조 설계

> 모든 소프트웨어 제품의 설계에는 `기능`과 `구조`라는 두 가지 측면이 존제한다.

- [설계의 목표]  
  - 설계의 가장 큰 도전은 기능과 구조라는 두 가지 측면을 함께 녹여 조화를 이루는 것이다.
  - 훌륭한 기능은 훌륭한 소프트웨어를 만들기 위한 충분 조건이다.
  - 반면 훌륭한 구조는 훌륭한 소프트웨어를 만들기 위한 필요 조건이다.



- [두 가지 재료: 기능과 구조]
  > 객체지향 세계를 구축하기 위해서는 사용자에게 제공할 `'기능'`과 기능을 담을 안정적인 `'구조'`라는 재료가 준비돼 있어야 한다.

  - 기능과 구조를 표현하기 위한 두 가지 기법
    - 구조는 이해 관계자들이 도메인(domain)에 관해 생각하는 개념과 개념들 간의 관계로 표현
    - 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현



- [안정적인 재료: 구조]
  - [도메인 모델]
    > 도메인: 사용자가 프로그램을 사용하는 대상 분야
    > 모델: 지식을 선택적으로 단순화 하고 의식적으로 구조화한 형태
        
    - 도메인 모델은 이해관계자들이 바라보는 멘탈 모델(Mental Model)이다.
      - 멘탈 모델이란 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다.
      - 제품을 설계할 때 제품에 관한 모든 것이 사용자들이 제품에 대해 가지고 있는 멘탈 모델과 정확하게 일치해야 한다 - 도널드 노먼



- [불안정한 재료: 기능]
  > 훌륭한 기능적 요구사항을 얻기 위해서는 목표를 가진 사용자와 사용자의 목표를 만족시키기 위해 일련의 절차를 수행하는 시스템 간의 `‘상호작용’` 관점에서 바라보아야 한다.
  
  - [유스케이스]
    > 사용자와 시스템 간의 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 말한다.

    - 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다.
    - 유스케이스는 설계 기법도, 객체지향 기법도 아니다. 유스케이스 안에는 영감을 불러일으킬 수 있는 약간의 힌트만이 들어 있을 뿐이다.

  - [유스케이스의 특성]
    1. 사용자와 시스템 간의 상호작용을 보여주는 ‘텍스트’다.
    2. 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.
    3. 단순한 피쳐(feature) 목록과 다르다.
    4. 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야한다.
    5. 내부 설계와 관련된 정보를 포함하지 않는다.



- [재료합치기: 기능과 구조]
  > [도메인 모델, 유스케이스, 그리고 책임-주도 설계]
  - 도메인 모델 ⇒ 안정적인 구조를 개념화 하기 위해 이용
  - 유스케이스 ⇒ 불안정한 기능을 서술하기 위해 이용
    - 이제 이것을 객체지향의 패러다임으로 가져와야 함

## 7장 함께 모으기

### 상호 연관 관점

- 개념 관점
  - 개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
  - 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 뜻하고, 소프트웨어는 이 도메인에 존재하는 문제를 해결하기 위해 개발된다.
  - 즉, 개념 관점에서의 설계는 사용자가 도메인읇 바라보는 관점을 반영하며, 실제 도메인의 규칙와 제약을 최대한 유사하게 반영하는 것이 핵심이다.
  - 객체지향의 세계에서 클래스가 현실 세계를 은유하는 것이 이 개념 관점이다.



- 명세 관점
  - 명세 관점에서 설계는 도메인 영역을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다.
  - 명세 관점은 도메인이 아닌 소프트웨어 내 객체들의 책임에 초점을 맞추기 때문에 객체의 인터페이스를 바라보게 된다.
  - 즉, 명세 관점에서의 설계는 객체가 협력을 위해 무엇을 할 수 있는가를 집중적으로 본다.
  - 이를 통해 인터페이스와 구현을 분리하는 객체지향의 기본적인 원칙을 준수한다.
  - 객체지향의 세계에서 클래스가 구현하는 공용 인터페이스가 이 명세 관점이다.



- 구현 관점
  - 구현 관점에서의 설계는 개발자에게 가장 익숙한 관점으로, 실제 작업을 수행하느 코드와 관련이 있다.
  - 구현 관점에서는 객체들이 책임을 수행하는 데 필요한 동작을 코드로 작성하는 데 초점을 두며,
  - 객체의 책임을 어떻게 수행할 것인가에 집중하여, 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스가 작성하게 된다.
  - 객체지향의 세계에서 클래스의 속성과 메서드의 작성이 이 구현 관점이다.

## 부록 A. 추상화 기법

### 분류와 인스턴스화

- 개념과 범주
  - 객체를 분류하고 **범주**로 묶는 것은 객체들의 특정 집합에 공통의 **개념**을 적용하는 것
  - 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류(classification)** 이라고 한다
  - 사람들은 분류를 통해서 개별 현상을 하나의 개념으로 다룬다. 이때 수많은 현상을 **객체**, 하나의 개념을 **타입**이라 한다
  - 분류는 객체를 타입과 연관시키는 것, 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 한다.
  - 객체지향의 세계에서 개념을 가리키는 용어는 **타입**이다.
  - 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 인스턴스라고 한다.



- 타입
  - 타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.
    - 심볼 : 타입을 가리키는 간략한 이름이나 명칭
    - 내연 : 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
    - 외연 : 타입에 속하는 모든 객체들의 집합



- 외연과 집합
  - 타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다.
  - 객체들은 서로 다른 집합에 표현될 수 있으며, 이때 객체들의 집합을 타입의 외연이라고 한다.
  - [단일 분류와 다중 분류의 차이]
    - 단일 분류(single classification) : 한 객체가 한 시점에 하나의 타입에 속하는 경우
    - 다중 분류(multiple classification) : 한 객체가 한 시점에 여러 타입에 속하는 경우 (다중 상속과 다르다)
  - [객체가 타입을 변경할 수 있는가]
    - 동적 분류(dynamic classification) : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
    - 정적 분류(static classification) : 객체가 자신의 타입을 변경할 수 없는 경우 (일반적인 언어)
    - 유연성이 반드시 필요한 경우, 다중 분류와 동적 분류를 구현할 수 있는 디자인 템플릿을 사용하는 것이 좋으며 일반적으로는 단일 분류와 정적 분류를 선택하는 것이 현명하다.



- 클래스
  - 클래스 기반의 객체지향 언어에서는 클래스는 객체가 공유하는 본질적인 속성을 정의한다.
  - 분류는 분류를 하는 사람과 기준에 따라 결과도 달라진다.
  - 클래스가 없는 프로토타입 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다. (ex. js)

### 일반화와 특수화

- 범주의 타입
  - 수많은 생물을 정리하기 위해서 **자연의 체계(Systema Naturae)** 가 등장했다.
    - 계(동물계) -> 문(척색동물문) -> 강(포유류강) -> 목(육식동물목) -> 과(고양이과) -> 속(고양이속) -> 종(고양이종)
  - 이러한 린네의 계층 구조는 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다.
    - 계층의 상위에 있는 범주가 하위 위치의 **범주의 일반화**, 하위의 범주는 계층의 상위의 위치한 **범주의 특수화**라고 한다.



- 서브타입
  - 객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화의 특수화는 계층 구조 안에 존재하는 타입간의 관계를 의미한다.
    - **슈퍼타입(supertype)** : 어떤 타입이 다른 타입보다 일반적인 경우
    - **서브타입(subtype)** : 어떤 타입이 다른 타입보다 좀 더 특수한 경우
  - 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'Is-a 규칙' 규칙을 준수해야한다.
    - **100% 규칙** : 슈퍼타입의 정의가 100% 서브 타입에 적용되야한다. 서브타입을 속성과 연관관계 면에서 슈퍼타입과 100%일치해야 한다.
    - **Is-a 규칙** : 서브 타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트한다.



- 상속
	- 프로그래밍 언어 세계에서 일반화, 특수화를 구현하는 대표적인 방법은 클래스 간의 상속이다. 다만, 모든 상속 관계가 일반화 관계는 아니다.
	- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서 슈퍼타입에 순응(conformance)해야한다. 즉, 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다.
	- 순응은 구조적인 순응과 행위적인 순응으로 나눠진다.
		- 구조적인 순응(structural conformance) : 타입의 내연과 관련된 100% 규칙을 의미한다.
		- 행위적인 순응(behavioral conformance) : 서브타입은 슈퍼타입을 행위적으로 대체가능해야한다. 이를 **리스코프 치환 원칙(Liskov Substitution Principle, LSP)** 이라고 한다.
	- 상속은 서브타이핑과 서브클래스의 두 가지 용도로 사용될 수 있다.
		- 서브타이핑(subtyping) : 서브클래스가 슈퍼클래스를 대체할 수 있는 경우, **인터페이스 상속(interface inheritance)**
		- 서브클래싱(subclassing) : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우, **구현 상속(implementation inheritance)**
	- 요약하면 **일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며 대체 가능성을 내포한다.**
	- 여러클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스간의 **위임(delegation)**을 말한다.
	- 클래스가 없는 프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이뤄진다. 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우, 객체와 객체를 상속 관계를 통해 연결한다.
	- 클래스 기반 언어와 프로토타입 기반 언어 모두 위임 메커니즘을 기반으로 메시지를 해석할 수 있는 대상을 선택한다.

### 집합과 분해

- 계층적인 복잡성
  - 호라와 템프스의 우화에서 얻을 수 있는 것은 다음과 같다.
    - 복잡성은 계층의 형태를 띈다.
    - 단순한 형태로부터 복잡한 형태로 진화하는데 걸리는 시간은 그 사이에 존재하는 안정적인 형태의 수와 분포에 의존한다.
  - 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**, 집합과 반대로 전체를 부분으로 분할하는 것을 **분해**라고 한다.
  - 집합은 전체의 내부로 불필요한 세부 사항을 배제하고 큰 이름에서 대상을 다룰 수 있게 해준다.

- 합성 관계
  - 객체와 객체 사이의 전체-부분 관게를 구현하기 위해서는 **합성 관계**를 사용해야한다.
  - 합성 관계로 연결된 객체들은 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거되는 경우가 많다.
  - 연관 관계로 연결된 객체들은 생명주기에 어떤 제약도 없다.

- 패키지
  - 합성 관계도 클래스가 많아지면 의존성 관리가 어렵다.
  - **패키지(package) 또는 모듈(module)** : 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성요소
  - 합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.]()