## 부록 A. 추상화 기법

### 분류와 인스턴스화

- 개념과 범주
  - 객체를 분류하고 **범주**로 묶는 것은 객체들의 특정 집합에 공통의 **개념**을 적용하는 것
  - 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류(classification)** 이라고 한다
  - 사람들은 분류를 통해서 개별 현상을 하나의 개념으로 다룬다. 이때 수많은 현상을 **객체**, 하나의 개념을 **타입**이라 한다
  - 분류는 객체를 타입과 연관시키는 것, 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 한다.
  - 객체지향의 세계에서 개념을 가리키는 용어는 **타입**이다.
  - 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 인스턴스라고 한다.



- 타입
  - 타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.
    - 심볼 : 타입을 가리키는 간략한 이름이나 명칭
    - 내연 : 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
    - 외연 : 타입에 속하는 모든 객체들의 집합



- 외연과 집합
  - 타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다.
  - 객체들은 서로 다른 집합에 표현될 수 있으며, 이때 객체들의 집합을 타입의 외연이라고 한다.
  - [단일 분류와 다중 분류의 차이]
    - 단일 분류(single classification) : 한 객체가 한 시점에 하나의 타입에 속하는 경우
    - 다중 분류(multiple classification) : 한 객체가 한 시점에 여러 타입에 속하는 경우 (다중 상속과 다르다)
  - [객체가 타입을 변경할 수 있는가]
    - 동적 분류(dynamic classification) : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
    - 정적 분류(static classification) : 객체가 자신의 타입을 변경할 수 없는 경우 (일반적인 언어)
    - 유연성이 반드시 필요한 경우, 다중 분류와 동적 분류를 구현할 수 있는 디자인 템플릿을 사용하는 것이 좋으며 일반적으로는 단일 분류와 정적 분류를 선택하는 것이 현명하다.



- 클래스
  - 클래스 기반의 객체지향 언어에서는 클래스는 객체가 공유하는 본질적인 속성을 정의한다.
  - 분류는 분류를 하는 사람과 기준에 따라 결과도 달라진다.
  - 클래스가 없는 프로토타입 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다. (ex. js)

### 일반화와 특수화

- 범주의 타입
  - 수많은 생물을 정리하기 위해서 **자연의 체계(Systema Naturae)** 가 등장했다.
    - 계(동물계) -> 문(척색동물문) -> 강(포유류강) -> 목(육식동물목) -> 과(고양이과) -> 속(고양이속) -> 종(고양이종)
  - 이러한 린네의 계층 구조는 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다.
    - 계층의 상위에 있는 범주가 하위 위치의 **범주의 일반화**, 하위의 범주는 계층의 상위의 위치한 **범주의 특수화**라고 한다.



- 서브타입
  - 객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화의 특수화는 계층 구조 안에 존재하는 타입간의 관계를 의미한다.
    - **슈퍼타입(supertype)** : 어떤 타입이 다른 타입보다 일반적인 경우
    - **서브타입(subtype)** : 어떤 타입이 다른 타입보다 좀 더 특수한 경우
  - 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'Is-a 규칙' 규칙을 준수해야한다.
    - **100% 규칙** : 슈퍼타입의 정의가 100% 서브 타입에 적용되야한다. 서브타입을 속성과 연관관계 면에서 슈퍼타입과 100%일치해야 한다.
    - **Is-a 규칙** : 서브 타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트한다.



- 상속
	- 프로그래밍 언어 세계에서 일반화, 특수화를 구현하는 대표적인 방법은 클래스 간의 상속이다. 다만, 모든 상속 관계가 일반화 관계는 아니다.
	- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서 슈퍼타입에 순응(conformance)해야한다. 즉, 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다.
	- 순응은 구조적인 순응과 행위적인 순응으로 나눠진다.
		- 구조적인 순응(structural conformance) : 타입의 내연과 관련된 100% 규칙을 의미한다.
		- 행위적인 순응(behavioral conformance) : 서브타입은 슈퍼타입을 행위적으로 대체가능해야한다. 이를 **리스코프 치환 원칙(Liskov Substitution Principle, LSP)** 이라고 한다.
	- 상속은 서브타이핑과 서브클래스의 두 가지 용도로 사용될 수 있다.
		- 서브타이핑(subtyping) : 서브클래스가 슈퍼클래스를 대체할 수 있는 경우, **인터페이스 상속(interface inheritance)**
		- 서브클래싱(subclassing) : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우, **구현 상속(implementation inheritance)**
	- 요약하면 **일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며 대체 가능성을 내포한다.**
	- 여러클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스간의 **위임(delegation)** 을 말한다.
	- 클래스가 없는 프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이뤄진다. 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우, 객체와 객체를 상속 관계를 통해 연결한다.
	- 클래스 기반 언어와 프로토타입 기반 언어 모두 위임 메커니즘을 기반으로 메시지를 해석할 수 있는 대상을 선택한다.

### 집합과 분해

- 계층적인 복잡성
  - 호라와 템프스의 우화에서 얻을 수 있는 것은 다음과 같다.
    - 복잡성은 계층의 형태를 띈다.
    - 단순한 형태로부터 복잡한 형태로 진화하는데 걸리는 시간은 그 사이에 존재하는 안정적인 형태의 수와 분포에 의존한다.
  - 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**, 집합과 반대로 전체를 부분으로 분할하는 것을 **분해**라고 한다.
  - 집합은 전체의 내부로 불필요한 세부 사항을 배제하고 큰 이름에서 대상을 다룰 수 있게 해준다.

- 합성 관계
  - 객체와 객체 사이의 전체-부분 관게를 구현하기 위해서는 **합성 관계**를 사용해야한다.
  - 합성 관계로 연결된 객체들은 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거되는 경우가 많다.
  - 연관 관계로 연결된 객체들은 생명주기에 어떤 제약도 없다.

- 패키지
  - 합성 관계도 클래스가 많아지면 의존성 관리가 어렵다.
  - **패키지(package) 또는 모듈(module)** : 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성요소
  - 합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.